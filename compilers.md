
# compilers

> program that translates source code into machine code that can be executed directly by the computer's processor

## compiled vs interpreted

- compiled languages: C, C++, Golang, Rust
  - source code is transformed into machine code (binary code) before it is executed
  - compiled binary is specific to the architecture and OS it was compiled for
  - a machine doesn't need the compiler to run the compiled executable
  - faster execution time
- interpreted languages: JavaScript, Python, Ruby
  - source code is executed line-by-line by an interpreter at runtime
  - as long as the OS has an interpreter, the code can be run on any platform
  - a machine needs the interpreter to run the source code
  - slower execution time

## compile time vs runtime

> [!IMPORTANT]
> compile time != runtime
> compile time: period when the source code is converted into machine code
> runtime: period when the program is actually running after it has been compiled

- compile time happens at runtime for interpreted languages
- time happens before runtime for compiled languages

## compilation process

> process that translates source code written in high level programming languages into machine code

1. preprocessor (hello.c => hello.i)
1. compiler (hello.i => hello.s)
1. assembler (hello.s => hello.o)
1. linker (hello.o => hello)
1. loader (hello)
1. execution

> [!NOTE]
> the file extensions used above are for the C programming language

- other languages' compiler/interpreter will translate to different types of files
  - for example, in python: file.py => bytecode => file.pyc
    - bytecode: AST (Abstract Syntax Tree) representation of python code
      - represents python code in a format that can be executed by the interpreter
      - it's not machine code

1. preprocessing: focuses on textual replacements and macro expansion
  - this is done by the preprocessor
  - generates expanded code
2. compilation: source code is compiled into assembly code
  - this is done by the compiler
3. assembly: assembly code is assembled into machine code
  - this is done by the assembler
  - machine code: binary representation of the code
4. linking: machine code is linked with libraries and other object files
  - this is done by the linker
  - object files: files that contain machine code that has been generated by a compiler or assembler
    - usually named with a .o or .obj extension
5. loading: executable file is loaded into memory by the operating system
  - also sets up necessary memory protection and access controls
  - access controls: restricts access of programs to computer resources
    - examples of access controls:
      - memory protection
      - file system access
      - network access
6. execution: CPU executes the machine code instructions in memory
  - fetches instructions from memory
  - decodes instructions
  - executes instructions according to the Instruction Set Architecture (ISA)

1. lexical analysis: converts source code into a stream of tokens (e.g. keywords, operators, identifiers)
  - tokenization: break source code into meaningful chunks called tokens
  - error detection: catch errors like unrecognized symbols or invalid characters
  - example:
    - input: `x = 2 + 3;`
    - output: tokens: `IDENTIFIER(x), ASSIGN(=), CONSTANT(2), PLUS(+), CONSTANT(3), SEMICOLON(;)`
2. parsing (syntax analysis): uses grammar rules to analyse token stream and build the AST*
  - Abstract Syntax Tree (AST): tree representation of the structure of source code written in a programming language
  - AST construction: combines tokens into tree nodes according to the programming languages grammar
3. semantic analysis: verify the AST for semantic correctness (e.g. type checking, scope resolution, error handling, etc)
4. intermediate code generation (IR): translate AST into an IR that is simpler and closer do machine code
5. optimization: improve the intermediate code for efficiency (reduce runtime or memory usage)
6. code generation: translate IR into machine code or assembly code for the target architecture
7. assembly and linking: convert assembly code into machine code using an assembler
8. loader and execution: prepare executable for execution
  - load executable into memory
  - set up the runtime environment
  - begin execution at the entry point (e.g. `main` function)
